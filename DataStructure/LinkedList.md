# Linked List 

## ADT (Abstract Data Type)
* 구체적인 기능의 완성과정을 언급하지 않고 기능이 무엇인지 나열한 것. 
* 기능 명세라고 보면 좋다! 

ex) 
```
typedef struct _wallet{
	int coint100Num;
	int bill5000Num;
}

#위와 같은 구조체 wallet에 대해서 
int TakeOutMoney(Wallet *pw, int coinNum, int billNum)
# 첫번째 인자의 지갑에서 두번째, 세번째 인자만큼 돈을 꺼낸다. 반환은 꺼낸 돈의 총액이 반환되고 돈이 차감됨
# 위와 같이 기능을 명시! 
```

## 리스트의 이해

** 리스트는 연결 리스트가 아니다. **
리스트는 구현방법에 따라서 두 가지로 나뉜다. 
* 순차리스트 ( 배열 기반 )
* 연결리스트 ( 메모리의 동적할당 기반)

구현 방법의 문제기 때문에 ADT가 동일해도 괜찮구 , 다를 수도 있음! 
즉 ADT는 표준이 아니고 사람과 회사에 따라서 다르며, 약속된 (ex 스택은 LIFO이다 라든지 ) 것만 구현되면 되는걸로 보임.

## 리스트 ADT

** 리스트는 데이터를 나란히 저장하고, 중복 데이터의 저장을 막지 않음! **

```
# 자바에서는 List를 인터페이스로 제공함 ㅎ.ㅎ 
void ListInit(List *plist); 
# 초기화할 리스트의 주소값을 인자로 전달 
# 리스트 생성후 제일 먼저 호출

void LInsert(List *plist,LData data);
# 리스트에 데이터를 저장 

int LFirst(List *plist,LData *pdata);
# 첫번째 데이터가 pdata가 가리키는 메모리에 저장 (즉, 첫번째 데이터를 검사해서 저장해줌, 참조용)
# 참조 성공시 1, 실패시 0 반환 

int LNext(List *plist,LData *pdata);
# 참조된 데이터의 다음데이터가 pdata가 가리키는 메모리에 저장 (즉, 참조한 것의 다음 데이터를 검사해서 저장해줌, 참조용)
# 순차 참조를 위해서 반복 호출이 가능함.

LData LRemove(List *plist);
# LFirst나 LNext의 마지막 반환 데이터를 삭제 
# 마지막 반환을 삭제하므로 연이은 반복 호출 안됨

int LCount(List *plist);
# 리스트에 저장되어있는 데이터 수 반환



## 순차랑 연결 리스트랑은 뭐가 달라? 
* 순차 리스트는 배열 기반이기때문의 리스트의 길이 설정이 달라질수가 없따 
* 연결 리스트에서 나오는 node는 교점이나 끈연결점 이런건데 항상 구슬이 형상화된다 구슬 꿰기 줄줄줄 
* 연결 리스트의 (내 방식의 수도 코드를 써보면)

```
struct _node를 정의한다. 
여기에는 실제로 들어갈 정보값인 data랑 
다음 노드의 포인터인 struct _node * next; 뿐임 

메인에서는 head,tail,그리고 현재 가리키고 있는 커서 노드를 null로 정의한다. 

새로 노드를 하나 추가할 땐 data 받아서 넣어주고, 다음 노드를 null로 
만약 head가 없으면 이 노드를 head로 삼아주고 있으면 tail 다음 노드를 new node로 삼아준다 
글고 방금 생긴 아기 노드가 구슬꿰기의 꼬리를 맡고 있으므로 tail 커서를 아기 노드로 옮겨준다 

데이터 출력은 요롷게 
커서를 head로 삼는다 
커서 데이터를 출력하구, 커서의 next가 null 이 아닐때까지 반복문을 돌리는데 
cur = cur -> next; 해버리고 계속 data 출력한다. 
역시 2학년 아니니까 이해된다 흑흑

데이터 삭제(메모리 해제는 요롷게)
head가 없으면 암것두 없는거니까 그냥 때려쳐 
있으면! 삭제할 노드를 헤드로, 삭제할 노드 다음 노드를 정의해주고 
free 해주면된다 next가 없어질때까지 반복이야 

```

## 머리에 추가하는 방법 vs 꼬리에 추가하는 방법 

* 머리에 추가하면 꼬리가 필요없는 대신 저장된 순서 유지가 안됨
* 꼬리에 추가하면 꼬리가 필요하고 저장된 순서가 유지됨 


