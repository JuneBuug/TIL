# Shell Script 기본 !

## 프로세스와 스레드

* 프로세스 : 실행중인 프로그램!
* 스레드 : 프로세스 실행의 최소 단위.

* 프로세스가 있으면 실행흐름이 기본적으로 1개 생긴다. 즉 스레드가 하나 생김!
core 하나 당 쓰레드 하나를 실행할 수 있음! 우리가 옥타 코어라고하면 쓰레드를 8개를 동시에 돌릴 수 있는 것! core가 하나여도 여러개 실행 할 수는 있지만, 그 core를 시간을 쪼개서 나눠써야함! 그래서 core가 많을 수록 **응답성** 이 좋아진다.

* 한 프로세스에 쓰레드가 여러개 있는 구조로도 짤 수 있다. 이를 **multi-threaded** 프로그램이라고 한다. 코드를 쓰레드 별로 나누고, 그걸 다시 합쳐서 동작하도록 쓰레드 별로 일을 할당 해줘야함. 쓰레드 갯수가 n일 때 n개 코어에 나눠서 실행되므로 실행시간이 이론적으로 1/n이 된다는 장점이 있다.

### Shell에서 파일을 실행하면 생기는 일
1. shell이 프로세스를 하나 생성함. 본인이랑 똑같은 프로세스로, A라고하자.(fork작업)
2. A를 실행한 프로그램(자식)으로 변경 (exec)
3. 프로그램이 완료되면 해당 프로세스는 사라짐

## 환경변수

```
echo $HOME
# home이라는 환경변수 출력하기
echo $Shell
# shell변수 출력하기 (현재 쓰고 있는 shell이 뭔지)
echo $PWD
# 현재 디렉토리 검사하는 스크립트 쓸 때는 $PWD를 쓰면된다!
```

**쉘스크립트는 무조건 붙여써야함**

## 쉘 스크립트 문법

```
$ export 변수명=값
#새로운 환경변수 설정, 자식 프로세스의 환경변수에만 전달함. 부모에겐 적용안됨
$ source 스크립트 파일
# 자식을 생성하지 않고 어떤 프로세스를 실행하는 명령어! 중요한 건 환경 변수들을 모아놓고 반영하고싶다 할 때 씀.
```


## 쉘 스크립트 파라미터

```
스크립트 param1 param2 ...
# 스크립트에 param1과 param2를 넣을 수 있다

$0 $1 $2 $3
#스크립트명  / 첫번째 파라미터 / 두번째 파라미터

$@
# 모든 파라미터

$RANDOM
# 랜덤한 수
```

## 리다이렉션

shell에서 입출력의 방향을 바꾸는 명령

```
표준입력 0 - 키보드
표준출력 1 - 터미널 화면
표준에러 2 - 터미널 화면
```
전통적으로, 키보드도 역시 파일의 일부야! 하고 생각함.
파일을 새로 열면, PID에 3번부터 번호를 붙여준다.
왜냐! stdin는 키보드(0번)고, stdout는 터미널(1번) stderr도 터미널이기때문(2번)

```
> : 표준 출력을 지정 파일로.
$ history > command.txt
# 내가 쳤던 명령어 들을  command.txt라는 파일에 출력 터미널 화면엔 출력하지않는다.
< : 키보드 대신 파일로부터 입력받음
# 기본 입력은 키보드지만 입력을 파일로 전환함. 그 파일에서 표준 출력하는 내용이 있으면 출력한다.
2> : 표준 에러를 지정파일로
# 에러도 터미널에 나오는데, 지정파일로 나온다.
2>&1  :표준 에러를 표준 출력으로
# 예시
.total.sh > result.txt 2>&1
# 이렇게 하면 result.txt에 표준 출력과 에러가 둘다 들어감
1>&2 : 표준 출력을 표준 에러로

```

## 파이프
리다이렉션과 파이프는 각각
파일과 프로그램의 결과라는 차이가 있음.

파이프는 앞 프로그램의 표준 출력이 후속 프로그램의 표준 입력으로 사용됨.
```
#예시
ps -A | grep ssh
# process 목록을 다 뽑고 그걸 input으로 써서, ssh라는 단어가 들어있는 애들만 고르겠다.

grep
# 표준 입력으로 받은게 파라미터랑 일치하면 표준 출력으로 보내줌

```


## 키보드 입력받기
```
$ read INPUT
# 키보드 입력을 실행함. 다음에 치는 말을 input으로 받음.
$ echo $INPUT
# 받은 INPUT을 출력해줌.
```
